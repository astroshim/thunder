#include "../include/ThreadQoS.h"
#include "../include/DownloadServer.h"
#include "../include/TcpSocket.h"
#include "../include/ServerSocket.h"
#include "../include/Client.h"
#include "../include/ClientUserDN.h"
#include "../include/NPLog.h"
#include "../include/NPUtil.h"

//#include "../include/IOMP_Select.h"
#include "../include/IOMP_EPoll.h"
//#include "../include/QoSQueue.h"

ThreadQoS::ThreadQoS(DownloadServer* const _pMainProcess)
							:m_pMainProcess(_pMainProcess)
{
	this->SetStarted(true);
	CNPLog::GetInstance().Log("ThreadQoS Construct");
}

ThreadQoS::ThreadQoS()
{
	this->SetStarted(false);
}

const int ThreadQoS::UpdateEPoll(Client* const _pClient, const unsigned int _uiEvents)
{       
    return m_pIOMP->ModifyFd(_pClient, _uiEvents);
}   

const int ThreadQoS::AddEPoll(Client* const _pClient, const unsigned int _uiEvents)
{   
//CNPLog::GetInstance().Log("epoll_Add (%p)", _pClient);
    return m_pIOMP->AddClient(_pClient, _uiEvents);
}

ThreadQoS::~ThreadQoS()
{
	this->SetStarted(false);
	CNPLog::GetInstance().Log("ThreadQoS Destruct");
}

void ThreadQoS::Run()
{
	 m_pIOMP = new IOMP_EPoll(1000);

	while(1)
	{
        int iEventCount;

        if((iEventCount = m_pIOMP->Polling()) <= 0)
        {
            //CNPLog::GetInstance().Log("epoll_wait error errno=%d, strerror=(%s)", errno, strerror(errno));
            continue;
        }

//CNPLog::GetInstance().Log("ThreadQoS epoll_event count=%d", iEventCount);
        for(int i = 0; i <iEventCount; ++i)
        {
            struct  epoll_event *tEvents= m_pIOMP->GetEventStructure();
            Client *pClient = static_cast<Client *>(tEvents[i].data.ptr);
			if(pClient == NULL)
			{
CNPLog::GetInstance().Log("ThreadQoS epoll_Error");
				m_pIOMP->DelClient(pClient);
				continue;
			}

            if(tEvents[i].events & (EPOLLERR | EPOLLHUP))
            {
                CNPLog::GetInstance().Log("QoS In EPOLLERR or EPOLLHUP disconnect (%p) (%d) errno=(%d)(%s)",
                        pClient, pClient->GetSocket()->GetFd(), errno, strerror(errno));
                errno = 0;
				m_pIOMP->DelClient(pClient);

#ifdef _CLIENT_ARRAY
	            m_pMainProcess->CloseClient(pClient->GetUserSeq());
#else
	            m_pMainProcess->CloseClient(pClient);
#endif
            }
			else
            if(tEvents[i].events & EPOLLOUT)
            {
        	    if(static_cast<ClientUserDN*>(pClient)->GetSendTime() < CNPUtil::GetMicroTime())
        	    //if(pClient->GetSendTime() < CNPUtil::GetMicroTime())
				{
//CNPLog::GetInstance().Log("ThreadQos POLLOUT Send to Sender=>>(%p)", pClient);
					m_pIOMP->DelClient(pClient);
					m_pMainProcess->PutSendQueue(pClient);
				}
/*
                if( ((ClientUserDN*)pClient)->GetSendPacketCount() > 0 &&
                    ((ClientUserDN*)pClient)->GetSendTime() < CNPUtil::GetMicroTime())
                {
//CNPLog::GetInstance().Log("In ThreadQoS =>>(%f), (%f)", ((ClientUserDN*)pClient)->GetSendTime(), CNPUtil::GetMicroTime());
                    m_pIOMP->DelClient(pClient);
                    m_pMainProcess->PutSendQueue(pClient);
                }
*/
            }

            continue;
        }

		CNPUtil::NanoSleep(1000000L);   // 0.1
	}

	pthread_exit(NULL);
}

